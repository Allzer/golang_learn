# golang_learn
Изучение golang
1) Для запуска файла: go run main.go
Для создания .exe-файла: go build main.go
Просто для билда нужен инициализированный модуль см п.3, написать go build

2) Любой файл должен наичнаться с package <название пакета>
package main - Точка входа. Главный файл

3) Для инициализации модуля:
go mod init <name>
--------------------
4) Переменные в go можно обозначать через var <название перерменной> = <значение> (типа присваивается автоматически, но можно указать явно после названия)

5) Переменной можно также присваивать значение через :=, но это не позволяет явно указать тип данных

6) Переменные можно указывать через запятую: var a, b float64 = 1, 1.317. Этот метод работает также со знаком присвоения :=, но также нельзя указать явно тип переменных

7) Для объявления констант использовать const <название константы> <тип данных (если нужен)> = <значение>

8) Существуют untype константы. Это происходит, когда явно не указан тип

9) Если у переменной нет значения, то будет присвоено нулевое значение для типа данных переменной (float64 = 0.0)

10) fmt.Println - для печати строки (следующий print будет на новой строке. Замена \n)

11) fmt.Printf - для вывода форматированной строки. Пример: fmt.Printf("Текст %v", peremennaia)

12) Для форматирования строки, как типа данных мы используем res := fmt.Sprintf("text %f", peremennaia)
--------------------
13) Пример базоваой функции:

	    func main() {
            output_res(1.8, 100)
        }

        func output_res(user_height float64, user_kg float64){ // указать тип/ы данных того, что будем возварщать. Чтобы указать несколько значений типы нужно указать в скобках
            imt := user_kg / math.Pow(user_height/100, 2)
            fmt.Println(imt)
        }

    Аргументы могут быть обозначены заранее, либо просто переданы значением
--------------------
14) Пример условного оператора:

	    if age > 10 {
			fmt.Println("курто")
		} else {
			fmt.Println("не курто")
		}

15) Обозначение условий: && - and, || - or. Остальное стандартно

16) if можно использовать с функциями: if func() > 0. Также можно использовать несколько функций: if func1() > func2

17) В if можно обозначать переменные и присваивать им значения/значения функции:

	    if rnak := getRnak(); rank == 'admin' {
	        // код
	    }
--------------------
18) Базовый цикл for:
    
	    for i:= 0; i<10; i++{
			fmt.Println(i)
		}

19) Импровизированный цикл while, но переменная должна быть объявлена заранее:

	    for i < 10 {
	        i++
	    }

20) Бесконечный цикл обозначается просто for:

	    for {
	        if <Условие> {
	            break
	        }
	    }
--------------------
21) Структура = Class в других языках программирования

22) Ключевое слово для обозначения структуры: 
    
	    type <name struct> struct {
	        field string
	        a, b int
	    }

23) Создание экзмепляров структуры:

	    data := <name struct>{"word", 1, 2}
	    data := <name struct>{
	        field: "word",
	        a: 1,
	        b: 2,
	    }

24) Если создаём структуру, не присываивая значения (data := <name struct>{}), то они будут заполнятся стандартно. В нашем случае field :='' (пустая строка), а переменные a и b будут равны 0

25) Для обращения к полям структуры нужно использовать следующий метод: word := data.field
    Также поля можно перезаписать. Это делается через знак равенства: data.field = "qwerty"

26) Для создания анонимных структур нужно использовать слово var. Доступ к полям структуры полчается также, как в обычной структуре
    
	    var <name struct> struct{
	        field string
	        a, b int
	    }

    Также анонимную структуру можно объявлять так:

        sample := struct {
            field string
            a, b int
        }{
            "hello",
            1,2,
        }
    
    Разница двух этих видов в том, что при использовании var полям структуры сразу даётся значение по умолчанию
--------------------
27) Массивы в go имеют фиксированный размер и не могут изменяться

28) Для создания массива: var <arrName> [количество элементов] <тип данных>
    
        var <arrName> [3]int // все значения изначально равны 0

        myArr := [3]int{7,8,9} // сразу присваиваем значения

        myArr := [...]int{7,8,9,10} // троеточие => количество элементов будет равно количеству присвоенных значений
        
        myArr := [4]int{7,8,9} // в данном случае 4 элемент массива будет равен 0 т.к его значение не указано

29) Чтение массива происходит посредством указания нужного индекса: myArr[0]

30) Если нужно присовить значение конкретному индексу, то нужно поставить знак равенства с нужным индексом: myArr[0] = 7

31) Чтобы присовить переменной значение массива: item1 = myArr[0]

32) Итерация по массиву:

        for i := 0; i < len(myArr); i++ {
            item := myArr[i]
            fmt.Println{item}
        }

33) Важно не выходить за рамки массива и использовать функцию len для определения количества итераций, чтобы не получать ошибки;
    Нельзя присваивать 4 элемент, если в массиве изначально указано 3 элемента (var myArr [3]int)
--------------------
34) Срезы динамичны и не имеют чёткого размера. Функции могут принимать срез в качестве параметра. При создании срез данные не копируются, а создаются методанные, которые ссылаются на массив

35) Можно создавать одновременно и базовые массивы, и срезы:

        mySlice := []int{1,2,3}

    Для доступа к элементам среза используется такой же синтаксис, как и для обращения к элементам массива:

        item1 := mySlice[0]

36) Срез обозначается также, как в питоне:

        slice[a,b] // a - начало среза, b - конец среза. Пропуск символов <[:]> обозначает выбор всех элементов от начала до конца

    Нельзя создать срез за пределами размера массива

37) Благодаря срезам можно создавать динамические массивы:

        arr := []int{1,2,3}
        arr = append(arr, 4, 5, 6) // С помощью append добавляем элементы: [1,2,3,4,5,6]

    Можно расширить один массив другим:

        arr1 := []int{1,2,3}
        arr2 := []int{4,5,6}

        arr1 = append(arr1, arr2...) // ... - для автоматической конвертации в нужные элементы

38) Функция make используется для пердварительного выделения памяти длля среза. Это полезно, когда количество элементов заранее известно, но их значения ещё не известны:

        slice := make([]int, 10) // значения по умолчанию равны 0

39) Если срез - параметр функции, то он может быть любого размера:

        func iterate(slice []int){
            for i:=0; i<len(slice); i++ {
                fmt.Println(i)
            }
        }

        small := []int{1,2}
        big := []int{1,2,3,4,5,6}
        
        iterate(small)
        iterate(big)

40) Можно создавать многомерные срезы:

        arr := [][]string {
            []string{"_","_","_"},
            {"_","_","_"},
            {"_","_","_"},
        }

        // для обращения: arr[1][0]
--------------------
41) Карты (словари Python). Данные в карте неупорядочены, в отличие от массива. Размер карты - динамический

42) Карту можно создать:

        myMap := make(map[string]int) // функция make предназначена для динамического выделения памяти и инициализации сложных типов данных
                                      // [string] - тип ключа, int - тип значения

        myMap := map[string]int{      // для создания карты с начальными значениями
            "item 1": 1,
            "item 2": 2,
            "item 3": 3,
        }

43) Операции со словарями (картами):

    //insert

        myMap["new_number"] = 5

    //read

        fav := myMap["new_number"]

    //del

        delete(myMap, "new_number")

    //check existence

        price, found := myMap["price"] //переменная price - фактическое значение по ключу, переменная found (bool) - указывает было ли найденно значение или нет

        if !found {
            fmt.Println("price not found")
            return
        }

44) Получение всех ключей/значений:

        myMap := make(map[string]int)

        for key, value := range myMap{ //возможно работает, как for i in arr в python 
            fmt.Println(key, value)
        }
--------------------
45) Указатели в golang — это переменные, которые хранят адрес другой переменной в памяти, чтобы не создавать новую. Это значит, что указатель указывает на место в памяти, где находится значение переменной

46) В go вызов функции осуществляется по значению (создаются копии всех аргументов функции) => вызов функций с большими структурами данных может быть относительно медленным. Этого можно избежать, используя указатели

47) Если мы хотим получить доступ к фактическим данным, которые находятся в памяти, то нужно выполнить разыменование указателя

48) Создание указателя
    Оператор разыменования "*" вместе с типом укзаывает, что значение является указателем
    "&" создаёт указатель на переменную

        value := 10
        var valuePtr *int //создаём переменную, которая является укзателем. Переменная указателя должна содержать в себе Ptr, чтобы остальные тоже понимали, что это указатель
        valuePtr = &value //& указывает на нужную переменную

    Также есть более короткий способ записи:

        value := 10
        valuePtr := &value //valuePtr имеет указатель на конкретную переменную в памяти

    Пример использования указателя:

        func increment(x *int) {
            *x += 1 //важно использовать разыменование, потому что по факту x является просто указателем на место в памяти
        }

        i := 1
        increment(&i)
        // i == 2
--------------------
49) Методы - функции, связанные с существующими структурами данных. Это позволяет точечно использовать нотацию с этими структурами
    Позволяте просто изменять структуры даныых

    Пример с использованием функции:

        type Coordinate struct {
            X, Y, int
        }

        func shiftBy(x, y int, coord *Coordinate) {
            coord.X += x
            coord.Y += y
        }

        coord := Coordinate{5, 5}
        shiftBy(1,1, &coord) //(6, 6)

    Пример с использование методов (указателей):

        type Coordinate struct {
            X, Y, int
        }

        func (coord *Coordinate) shiftBy(x, y int) {
            coord.X += x
            coord.Y += y
        }

        coord := Coordinate{5, 5}
        coord.shiftBy(1,1) //использование точечной нотации

    Пример с использование методов (значение): //т.к мы используем значение, то мы создаём копию структуры и работаем с ней

        type Coordinate struct {
            X, Y, int
        }

        func (c Coordinate) Dist(other Coordinate) Coordinate{
            return Coordinate{c.X-other.X, c.Y-other.y}
        }

        first := Coordinate{2,2}
        second := Coordinate{1,5}
        distnce := first.Dist(second) //(-1,3)
--------------------
50) Ключевое слово iota. Это слово используется для работы с константами. Часто применяется группировка констант

        const (
            Online = 0
            Ofline = 1
            Maintenance = 2
            Retired = 3
        )
        
        const (
            Online = iota //добавляет все тежи значения констант, что и выше, но автоматически
            Ofline
            Maintenance
            Retired
        )

    Также можно пропускать значения iota 
        
        const (
            s1 = iota
            -
            s3 //2
        )
    
    Или начинать с определённого значения

        const (
            s1 = iota + 3
            s2 //4
            s3 //5
        )
--------------------
51) Тестирование
    Тесты пишутся в отденльных файлах, используя имя файла, который они тестируют: clientApi.go -> clinetApi_test.go
    Модульные тесты должны находиться в том же пакете

52) Чтобы запустить тесты нужно использовать пакет testing. Он нужен для создания иестов и должен быть импортирован в каждом файле с тестами

53) Пример:
    main.go

        package main

        import "regexp"

        func IsValidEmail(addr string) bool {
            re, ok := regexp.Compile(`.+@.+\..+`)
            if ok != nil{
                panic("failed to compile regex")
            } else{
                return re.Match([]byte(addr))
            }
        }

    main_test.go

        package main

        import "testing"

        func TestIsValidEmail(t *testing.T){
            data := "email@example.com"
            if !IsValidEmail(data) {
                t.Errorf("IsValidEmail(%v)=false, want true", data)
            }
        }
    
    Для запуска тестов нужно предваарительно создать модуль и написать в консоль:

        go test

54) Есть ключевые слова для тестов:

        Fail() - пометить тест, как непройденный
        Errorf(string) - пометить, как непройденный + написать ошибку
        FailNow() - пометить тест, как непройденный и прерывает выполненеие теста дальше
        Fatalf(string) - пометить тест, как непройденный прерывает выполненеи и добавить сообщение
        Logf() - выводит сообщение только при неуспешном тесте

55) Тестовые таблицы:

        func TestIsValidEmailTable(t *testing.T) {
            table := []struct {
                email string
                want bool
            }{
                {"example@mail.com", true},
                {"miss@tld", false},
            }

            for _, data := range table {
                result := IsValidEmail(data.email)
                if result != data.want {
                    t.Errorf("%v: %tm want: %t", data.email, result, data.want)
                }
            }
        }
--------------------
56) Интерфейсы позволяют определять поведение типа данных. Они позволяют функциям работать с разными типами данных

        type MyInterface interface {
            Function1()
            Function2(x int) int
        }

        type MyType int
        func (m MyType) Function1() {}
        func (m MyType) Function2(x int) int {
            return x + x
        }

        func execute(i MyInterface) {
            i.Function1()
        }

        func main() {
            m := MyType(1)
            execute(m)
            execute(&m)
        }
